# pip install selenium webdriver-manager == run in shell terminal
from selenium import webdriver
from selenium.webdriver.chrome.service import Service
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from webdriver_manager.chrome import ChromeDriverManager
import time
import random
import json

# ================= CONFIG =================
TARGET_PROFILE_URL = "https://www.facebook.com/profile.php?id=61585418971161"  # Jeremi Folts

# List of accounts (use a small number for testing)
ACCOUNTS = [
    {"email": "your_email1@example.com", "password": "your_password1"},
    {"email": "your_email2@example.com", "password": "your_password2"},
    # Add more accounts here...
]

SLOW_MODE = True          # True = very human-like (recommended to avoid instant ban)
MAX_ATTEMPTS_PER_ACCOUNT = 1  # Number of requests to send from each account
MIN_DELAY = 25            # seconds between actions
MAX_DELAY = 90
USE_USER_DATA_DIRS = False  # Set to True to use separate browser profiles
ANTI_DETECTION = True    # Add anti-detection measures

# ===========================================

def human_delay(min_sec=3, max_sec=12):
    """Add random delays to mimic human behavior"""
    sleep_time = random.uniform(min_sec, max_sec)
    time.sleep(sleep_time)
    return sleep_time

def random_scroll(driver):
    """Random scroll to mimic human behavior"""
    scroll_height = random.randint(200, 800)
    driver.execute_script(f"window.scrollBy(0, {scroll_height});")
    time.sleep(random.uniform(0.5, 2))

def setup_driver(account_index=0, use_profile=False):
    """Setup Chrome driver with anti-detection measures"""
    chrome_options = Options()
    
    # Basic options
    chrome_options.add_argument("--disable-notifications")
    chrome_options.add_argument("--disable-popup-blocking")
    chrome_options.add_argument("--disable-infobars")
    
    # Anti-detection measures
    if ANTI_DETECTION:
        # Randomize window size
        width = random.randint(1024, 1920)
        height = random.randint(768, 1080)
        chrome_options.add_argument(f"--window-size={width},{height}")
        
        # Add language preferences
        chrome_options.add_argument("--lang=en-US")
        
        # Disable automation flags
        chrome_options.add_experimental_option("excludeSwitches", ["enable-automation"])
        chrome_options.add_experimental_option('useAutomationExtension', False)
        
        # Use different user agent (optional)
        user_agents = [
            "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36",
            "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/119.0.0.0 Safari/537.36",
            "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36",
        ]
        chrome_options.add_argument(f'user-agent={random.choice(user_agents)}')
    
    # Use separate user data directories for each account to avoid login conflicts
    if use_profile and USE_USER_DATA_DIRS:
        profile_path = f"./chrome_profile_{account_index}"
        chrome_options.add_argument(f"user-data-dir={profile_path}")
    
    # Never use headless mode for Facebook
    # chrome_options.add_argument("--headless")  # DO NOT ENABLE
    
    # Initialize driver
    service = Service(ChromeDriverManager().install())
    driver = webdriver.Chrome(service=service, options=chrome_options)
    
    # Execute anti-detection script
    if ANTI_DETECTION:
        driver.execute_script("Object.defineProperty(navigator, 'webdriver', {get: () => undefined})")
    
    return driver

def login(driver, email, password, account_num):
    """Login to Facebook with given credentials"""
    print(f"\n{'='*50}")
    print(f"Account #{account_num}: Attempting login for {email}")
    print('='*50)
    
    driver.get("https://www.facebook.com")
    wait = WebDriverWait(driver, 30)
    
    try:
        # Wait for page to load
        wait.until(EC.presence_of_element_located((By.TAG_NAME, "body")))
        human_delay(2, 5)
        
        # Check if already logged in (if using profiles)
        if "login" not in driver.current_url.lower() and "facebook.com/home" in driver.current_url:
            print("Already logged in via saved session")
            return True
        
        # Enter email
        email_field = wait.until(EC.presence_of_element_located((By.ID, "email")))
        human_delay(1, 3)
        for char in email:
            email_field.send_keys(char)
            time.sleep(random.uniform(0.05, 0.2))
        
        # Enter password
        pass_field = driver.find_element(By.ID, "pass")
        human_delay(1, 2)
        for char in password:
            pass_field.send_keys(char)
            time.sleep(random.uniform(0.05, 0.2))
        
        # Submit
        human_delay(1, 3)
        pass_field.send_keys(Keys.RETURN)
        print("Login submitted...")
        
        # Wait for login to complete
        human_delay(5, 10)
        
        # Check for checkpoint/2FA
        if "checkpoint" in driver.current_url or "login/device-based" in driver.current_url:
            print("\n⚠️  CHECKPOINT DETECTED!")
            print("Facebook is asking for additional verification.")
            print(f"Please complete the verification manually in the browser for account: {email}")
            print("You have 60 seconds to complete it...")
            
            for i in range(60):
                time.sleep(1)
                if "checkpoint" not in driver.current_url and "login/device-based" not in driver.current_url:
                    print("Checkpoint resolved!")
                    break
            else:
                print("Checkpoint not resolved in time. Continuing anyway...")
        
        # Wait for home page
        wait.until(EC.presence_of_element_located((By.XPATH, "//div[contains(@role, 'main')] | //div[@id='ssrb_root_start']")))
        human_delay(5, 10)
        print(f"✓ Successfully logged in as {email}")
        return True
        
    except Exception as e:
        print(f"✗ Login failed: {str(e)[:100]}...")
        print("Possible issues:")
        print("1. Wrong credentials")
        print("2. Account disabled/blocked")
        print("3. Captcha required")
        print("4. Network issue")
        return False

def send_friend_request(driver, profile_url, account_email):
    """Send friend request to target profile"""
    print(f"\nSending friend request from {account_email}...")
    
    try:
        # Navigate to target profile
        driver.get(profile_url)
        wait = WebDriverWait(driver, 20)
        
        # Wait for profile to load
        wait.until(EC.presence_of_element_located((By.TAG_NAME, "body")))
        
        # Random scroll to mimic human
        random_scroll(driver)
        human_delay(3, 7)
        
        # Try different selectors for the "Add Friend" button
        button_selectors = [
            "//div[@aria-label='Add Friend']",
            "//div[contains(@aria-label, 'Add Friend')]",
            "//span[text()='Add Friend']/parent::div",
            "//div[text()='Add Friend']",
            "//div[contains(text(), 'Add Friend')]",
            "//button[contains(@aria-label, 'Add Friend')]",
            "//a[contains(@aria-label, 'Add Friend')]",
        ]
        
        add_button = None
        for selector in button_selectors:
            try:
                add_button = driver.find_element(By.XPATH, selector)
                if add_button.is_displayed() and add_button.is_enabled():
                    print(f"Found button with selector: {selector}")
                    break
            except:
                continue
        
        if not add_button:
            # Try one more time with explicit wait
            try:
                add_button = wait.until(EC.element_to_be_clickable(
                    (By.XPATH, "//div[@aria-label='Add Friend' or contains(@aria-label, 'Add Friend')]")
                ))
            except:
                pass
        
        if add_button:
            # Scroll to button
            driver.execute_script("arguments[0].scrollIntoView({behavior: 'smooth', block: 'center'});", add_button)
            human_delay(1, 3)
            
            # Click the button
            driver.execute_script("arguments[0].click();", add_button)
            print("✓ Friend request sent successfully!")
            
            # Verify success by checking for "Friend Request Sent" button
            human_delay(2, 4)
            try:
                sent_selectors = [
                    "//span[text()='Friend Request Sent']",
                    "//div[contains(text(), 'Request Sent')]",
                    "//div[@aria-label='Friend Request Sent']",
                ]
                for selector in sent_selectors:
                    try:
                        if driver.find_element(By.XPATH, selector):
                            print("✓ Confirmed: Friend request was sent")
                            return True
                    except:
                        continue
            except:
                pass
            
            return True
        else:
            # Check if already friends or request already sent
            try:
                existing_selectors = [
                    "//span[text()='Friends']",
                    "//div[text()='Friends']",
                    "//span[text()='Friend Request Sent']",
                    "//div[contains(text(), 'Respond to Friend Request')]",
                ]
                for selector in existing_selectors:
                    try:
                        if driver.find_element(By.XPATH, selector):
                            print("⚠️  Already friends or request already sent")
                            return False
                    except:
                        continue
            except:
                pass
            
            print("✗ Could not find 'Add Friend' button")
            return False
            
    except Exception as e:
        print(f"✗ Error sending request: {str(e)[:100]}...")
        return False

def account_session(driver, account, account_num):
    """Handle a single account session"""
    email = account["email"]
    password = account["password"]
    
    # Login
    if not login(driver, email, password, account_num):
        return False
    
    # Send friend request
    success = send_friend_request(driver, TARGET_PROFILE_URL, email)
    
    # Logout (optional)
    if False:  # Set to True if you want to logout after each account
        try:
            driver.get("https://www.facebook.com/logout")
            human_delay(2, 4)
            logout_btn = driver.find_element(By.XPATH, "//span[text()='Log Out']/parent::div")
            logout_btn.click()
            human_delay(3, 6)
        except:
            pass
    
    return success

# ================= MAIN EXECUTION =================
def main():
    print("""
    ⚠️  IMPORTANT WARNINGS ⚠️
    1. Use this script responsibly and ethically
    2. Facebook may block accounts if you send too many requests
    3. Always test with 1-2 accounts first
    4. Use real accounts (new accounts get blocked quickly)
    5. Keep delays between actions
    6. NEVER commit your real passwords to GitHub
    """)
    
    if input("Type 'YES' to continue: ").upper() != "YES":
        print("Script cancelled.")
        return
    
    print(f"\nTarget: {TARGET_PROFILE_URL}")
    print(f"Number of accounts: {len(ACCOUNTS)}")
    print(f"Slow mode: {SLOW_MODE}")
    print(f"Max attempts per account: {MAX_ATTEMPTS_PER_ACCOUNT}")
    
    results = []
    
    for i, account in enumerate(ACCOUNTS, 1):
        print(f"\n{'#'*60}")
        print(f"PROCESSING ACCOUNT {i} of {len(ACCOUNTS)}")
        print(f"{'#'*60}")
        
        try:
            # Setup driver for this account
            driver = setup_driver(i, use_profile=True)
            
            # Run account session
            success = account_session(driver, account, i)
            
            results.append({
                "account": account["email"],
                "success": success,
                "number": i
            })
            
            # Close driver (or keep open for debugging)
            if i < len(ACCOUNTS):  # Not the last account
                if input(f"\nContinue with next account? (y/n): ").lower() != 'y':
                    driver.quit()
                    break
                
                # Long delay between accounts
                if SLOW_MODE and i < len(ACCOUNTS):
                    delay = random.randint(MIN_DELAY, MAX_DELAY)
                    print(f"\nWaiting {delay} seconds before next account...")
                    time.sleep(delay)
            
            driver.quit()
            
        except Exception as e:
            print(f"✗ Error with account {i}: {str(e)[:100]}...")
            results.append({
                "account": account["email"],
                "success": False,
                "error": str(e)[:100]
            })
    
    # Summary
    print(f"\n{'='*60}")
    print("RESULTS SUMMARY")
    print('='*60)
    successful = sum(1 for r in results if r.get("success"))
    print(f"Successful requests: {successful}/{len(ACCOUNTS)}")
    
    for r in results:
        status = "✓ SUCCESS" if r.get("success") else "✗ FAILED"
        print(f"Account {r.get('number')}: {r.get('account')} - {status}")

if __name__ == "__main__":
    main()
